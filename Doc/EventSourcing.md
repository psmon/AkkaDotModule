# EventSourcing

이벤트 소싱의 개념을 살펴보고

실천형 아키텍트를 위해 AKKA.net를 통해 실행가능한 코드 샘플도 살펴보겠습니다.



# CRUD와 차이점

이벤트 소싱을 이해하기위해, 전통적인 CRUD(Create Read Update Delete)방식에 대해 이해가 필요합니다.

CRUD는 일반적으로 어떤 로직을 처리하고 그 결과값만을 저장합니다.

![](e-curd.png)

전통적인 방식이며 대부분의 데이터 처리에 적합하지만 

다음과 같은 문제점이 있을수 있습니다.

- 무결성을 유지하면서 결과를 계속 유지하는것은 단일지점 성능비용이 듭니다.
- 분석팀에서 사용자가 바나나를 제거했다란 사실을 찾을수가 없습니다.
- 바나나를 찾기위한 기능을 구현하기위해 상류팀에서는 새로운 CRUD를 또 작성하게됩니다.
- 새로운 기능이 추가되었다고 해도,과거에 발생한 이벤트를 찾을수 없습니다.


# 이벤트 저장

![](e-storeevent.png)

이벤트 소싱은 커다란 웹사이트를 수십억명의 사용자 규모로 확장하는 아이디어이며

이 아이디어는 매우 간답합니다. 메시지가 발생할때 명령의 이벤트 목록을 생성하고 저장을 합니다.

이 계획은 이벤트만이 저장소에 추가되고 아무것도 변이되지 않는 점이며 

이를 통해 이벤트 스트림의 소비자를 완벽하게 복제하고 확장할수 있습니다. 

이벤트 소싱을 실현하기 위해서, AKKA에서 PersistenceActor 가 사용이 됩니다.

# 이벤트 재생(스트림 소비자)

![](e-playevent.png)

이벤트를 생성하는 팀과 그것을 활용하여 이용하는팀은 다를수 있으며

이벤트 소싱은 MSA관점에서도 적합합니다. 그리고 요즘 대세인 KAFKA의 생산과 소비의 분리라는 컨셉과도

유사하기때문에 KAFKA를 활용하여, 단순한 대용량 메시지 전송이 아닌 대용량 서비스를 설계할수도 있습니다.

또한 스트림을 소비하는 개발팀에서는, 이벤트재생을 통해 다양한 기능을 독립적으로 만들어 낼수 있습니다.

이벤트 소싱은 CQRS의 일부로 이러한 명령과 조회 책임의 분리는 정확하게는 CQRS에서 이야기하고 있는내용입니다.


    영역이 약간 다르지만, 쉬운예로 스타크래프트의 리플레이 재생기를 통해 이해하면 쉬울것같습니다.

    스타크래프트 리플레이기의 소스를 볼수없지만 CQRS와 이벤트 소싱을 이해하기 좋은 예이며

    게임중 게임에 발생하는 이벤트 자체만을 저장하고 게임이 끝난후 게임플레이를 볼수 있습니다. (저장과 재생의 책임분리)

    하지만 다양한 서드파티 개발자들은 이 이벤트를 활용하여 

    APM측정,자원효율분석기,시간대별 생산량등 다양한 기능을 독립적으로 만들어낼수 있습니다.(이벤트소싱)

    또한 이것은 리마스터를 통해 더 좋은 그래픽으로 재생될수 있습니다.


# 이벤트 스냅샷

![](e-snapshot.png)

이벤트 소싱의 단점으로, 너무많은 이벤트를 재생하게 될시 재생성능이 느려질수 있습니다.
이에 대한 보완으로 중간처리를 집계하는 스냅샷을 사용하게 됩니다.
스냅샷이후 부터재생하여 최종결과를 빠르게 재생할수 있습니다.

# 구현부

위 컨셉이 이해되면 다음 구현부를 사용하여 이벤트 소싱을 작동시킬수 있습니다.

- 이벤트 소싱구현 : https://getakka.net/articles/persistence/event-sourcing.html
- 스냅샷 구현: https://getakka.net/articles/persistence/snapshots.html


# 기타참고자료
- KAFKA with CQRS : https://www.confluent.io/blog/event-sourcing-cqrs-stream-processing-apache-kafka-whats-connection/
- CQRS : https://justhackem.wordpress.com/2016/09/17/what-is-cqrs/


